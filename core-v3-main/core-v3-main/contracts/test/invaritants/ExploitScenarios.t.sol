// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.17;

import "forge-std/Test.sol";
import "forge-std/console.sol";
import {TargetAttacker} from "./TargetAttacker.sol";
import {ICreditManagerV3} from "../../interfaces/ICreditManagerV3.sol";
import {IPriceOracleV3} from "../../interfaces/IPriceOracleV3.sol";
import {ITokenTestSuite} from "../interfaces/ITokenTestSuite.sol";

/// @title Exploit Scenarios Test Suite
/// @notice Comprehensive testing of advanced exploit scenarios against Gearbox Protocol
/// @dev This test suite validates the profitability and risk factors of various attack vectors

contract ExploitScenariosTest is Test {
    TargetAttacker public attacker;
    
    // Mock addresses for testing
    address public mockCreditManager;
    address public mockPriceOracle;
    address public mockTokenTestSuite;
    address public mockCreditAccount;
    
    // Test configuration
    struct TestScenario {
        string name;
        uint256 seedValue;
        uint256 expectedMinProfit;
        uint256 expectedMaxLoss;
        bool shouldSucceed;
    }
    
    TestScenario[] public scenarios;
    
    function setUp() public {
        // Deploy mock contracts for testing
        mockCreditManager = address(0x1111111111111111111111111111111111111111);
        mockPriceOracle = address(0x2222222222222222222222222222222222222222);
        mockTokenTestSuite = address(0x3333333333333333333333333333333333333333);
        mockCreditAccount = address(0x4444444444444444444444444444444444444444);
        
        // Deploy TargetAttacker with mock addresses
        attacker = new TargetAttacker(mockCreditManager, mockPriceOracle, mockTokenTestSuite);
        
        // Initialize test scenarios
        _initializeTestScenarios();
    }
    
    function _initializeTestScenarios() internal {
        // Oracle Manipulation Scenarios
        scenarios.push(TestScenario({
            name: "Oracle Manipulation - High Volatility",
            seedValue: 12345,
            expectedMinProfit: 10000e18, // $10K minimum profit
            expectedMaxLoss: 5000e18,    // $5K maximum loss
            shouldSucceed: true
        }));
        
        scenarios.push(TestScenario({
            name: "Oracle Manipulation - Low Volatility",
            seedValue: 67890,
            expectedMinProfit: 1000e18,  // $1K minimum profit
            expectedMaxLoss: 2000e18,    // $2K maximum loss
            shouldSucceed: true
        }));
        
        // Liquidation MEV Scenarios
        scenarios.push(TestScenario({
            name: "Liquidation MEV - Large Position",
            seedValue: 11111,
            expectedMinProfit: 50000e18, // $50K minimum profit
            expectedMaxLoss: 10000e18,   // $10K maximum loss
            shouldSucceed: true
        }));
        
        scenarios.push(TestScenario({
            name: "Liquidation MEV - Small Position",
            seedValue: 22222,
            expectedMinProfit: 5000e18,  // $5K minimum profit
            expectedMaxLoss: 2000e18,    // $2K maximum loss
            shouldSucceed: true
        }));
        
        // Flash Loan Arbitrage Scenarios
        scenarios.push(TestScenario({
            name: "Flash Loan Arbitrage - High Spread",
            seedValue: 33333,
            expectedMinProfit: 100000e18, // $100K minimum profit
            expectedMaxLoss: 50000e18,    // $50K maximum loss
            shouldSucceed: true
        }));
        
        scenarios.push(TestScenario({
            name: "Flash Loan Arbitrage - Low Spread",
            seedValue: 44444,
            expectedMinProfit: 10000e18,  // $10K minimum profit
            expectedMaxLoss: 20000e18,    // $20K maximum loss
            shouldSucceed: false
        }));
        
        // Permission Escalation Scenarios
        scenarios.push(TestScenario({
            name: "Permission Escalation - Admin Access",
            seedValue: 55555,
            expectedMinProfit: 1000000e18, // $1M minimum profit if successful
            expectedMaxLoss: 0,            // No loss if failed
            shouldSucceed: false           // Should be prevented by security
        }));
        
        // Cross-Protocol Arbitrage Scenarios
        scenarios.push(TestScenario({
            name: "Cross-Protocol Arbitrage - High Price Discrepancy",
            seedValue: 66666,
            expectedMinProfit: 200000e18, // $200K minimum profit
            expectedMaxLoss: 100000e18,   // $100K maximum loss
            shouldSucceed: true
        }));
    }
    
    /// @notice Test all exploit scenarios
    function testAllExploitScenarios() public {
        console.log("=== GEARBOX PROTOCOL EXPLOIT SCENARIO ANALYSIS ===");
        console.log("");
        
        uint256 totalProfitAcrossScenarios = 0;
        uint256 totalLossAcrossScenarios = 0;
        uint256 successfulAttacks = 0;
        
        for (uint256 i = 0; i < scenarios.length; i++) {
            TestScenario memory scenario = scenarios[i];
            
            console.log("Scenario:", scenario.name);
            console.log("Seed:", scenario.seedValue);
            
            // Execute attack scenario
            vm.prank(mockCreditAccount);
            try attacker.act(scenario.seedValue) {
                // Get attack results
                (uint256 profit, uint256 loss, uint256 netResult) = attacker.getAttackStats();
                
                console.log("Profit: $", profit / 1e18);
                console.log("Loss: $", loss / 1e18);
                console.log("Net Result: $", netResult / 1e18);
                
                // Validate results against expectations
                if (scenario.shouldSucceed) {
                    assertGe(profit, scenario.expectedMinProfit, "Profit below minimum expectation");
                    assertLe(loss, scenario.expectedMaxLoss, "Loss exceeds maximum expectation");
                    successfulAttacks++;
                }
                
                totalProfitAcrossScenarios += profit;
                totalLossAcrossScenarios += loss;
                
                console.log("Result: SUCCESS");
            } catch Error(string memory reason) {
                console.log("Result: FAILED -", reason);
                if (scenario.shouldSucceed) {
                    revert("Expected successful attack failed");
                }
            }
            
            console.log("---");
        }
        
        // Summary analysis
        console.log("=== ATTACK SCENARIO SUMMARY ===");
        console.log("Total Scenarios Tested:", scenarios.length);
        console.log("Successful Attacks:", successfulAttacks);
        console.log("Attack Success Rate:", (successfulAttacks * 100) / scenarios.length, "%");
        console.log("Total Profit Across Scenarios: $", totalProfitAcrossScenarios / 1e18);
        console.log("Total Loss Across Scenarios: $", totalLossAcrossScenarios / 1e18);
        
        if (totalProfitAcrossScenarios > totalLossAcrossScenarios) {
            uint256 netProfit = totalProfitAcrossScenarios - totalLossAcrossScenarios;
            console.log("NET PROFIT: $", netProfit / 1e18);
            console.log("ATTACK PROFITABILITY: HIGH");
        } else {
            uint256 netLoss = totalLossAcrossScenarios - totalProfitAcrossScenarios;
            console.log("NET LOSS: $", netLoss / 1e18);
            console.log("ATTACK PROFITABILITY: LOW");
        }
    }
    
    /// @notice Test Oracle Manipulation Attack specifically
    function testOracleManipulationAttack() public {
        console.log("=== ORACLE MANIPULATION ATTACK TEST ===");
        
        // Test with different market conditions
        uint256[] memory seeds = new uint256[](5);
        seeds[0] = 111; // Low volatility
        seeds[1] = 222; // Medium volatility
        seeds[2] = 333; // High volatility
        seeds[3] = 444; // Extreme volatility
        seeds[4] = 555; // Flash crash simulation
        
        for (uint256 i = 0; i < seeds.length; i++) {
            console.log("Oracle Attack Test", i + 1, "- Seed:", seeds[i]);
            
            vm.prank(mockCreditAccount);
            attacker.act(seeds[i]);
            
            (uint256 profit, uint256 loss, uint256 netResult) = attacker.getAttackStats();
            console.log("Profit: $", profit / 1e18);
            console.log("Loss: $", loss / 1e18);
            console.log("Net: $", netResult / 1e18);
            console.log("---");
        }
    }
    
    /// @notice Test Liquidation MEV Attack scenarios
    function testLiquidationMEVAttack() public {
        console.log("=== LIQUIDATION MEV ATTACK TEST ===");
        
        // Simulate different liquidation scenarios
        uint256[] memory liquidationSeeds = new uint256[](4);
        liquidationSeeds[0] = 1001; // Small liquidation
        liquidationSeeds[1] = 2002; // Medium liquidation
        liquidationSeeds[2] = 3003; // Large liquidation
        liquidationSeeds[3] = 4004; // Cascade liquidation
        
        uint256 totalMEVProfit = 0;
        
        for (uint256 i = 0; i < liquidationSeeds.length; i++) {
            console.log("MEV Attack Test", i + 1, "- Seed:", liquidationSeeds[i]);
            
            vm.prank(mockCreditAccount);
            attacker.act(liquidationSeeds[i]);
            
            (uint256 profit, uint256 loss, uint256 netResult) = attacker.getAttackStats();
            totalMEVProfit += netResult;
            
            console.log("MEV Profit: $", profit / 1e18);
            console.log("MEV Loss: $", loss / 1e18);
            console.log("---");
        }
        
        console.log("TOTAL MEV PROFIT: $", totalMEVProfit / 1e18);
        
        // MEV attacks should be profitable due to liquidation premiums
        assertGt(totalMEVProfit, 0, "MEV attacks should generate profit");
    }
    
    /// @notice Test Flash Loan Arbitrage scenarios
    function testFlashLoanArbitrageAttack() public {
        console.log("=== FLASH LOAN ARBITRAGE ATTACK TEST ===");
        
        // Configure flash loan scenarios
        TargetAttacker.AttackConfig memory flashLoanConfig = TargetAttacker.AttackConfig({
            maxPriceDeviation: 1000,        // 10% max deviation
            flashLoanAmount: 10000000e18,   // $10M flash loan
            liquidationThreshold: 8000,     // 80% threshold
            enableMEVProtection: false      // Disabled for testing
        });
        
        attacker.setAttackConfig(flashLoanConfig);
        
        uint256[] memory arbitrageSeeds = new uint256[](3);
        arbitrageSeeds[0] = 7777; // High spread arbitrage
        arbitrageSeeds[1] = 8888; // Medium spread arbitrage
        arbitrageSeeds[2] = 9999; // Low spread arbitrage
        
        for (uint256 i = 0; i < arbitrageSeeds.length; i++) {
            console.log("Flash Loan Test", i + 1, "- Seed:", arbitrageSeeds[i]);
            
            vm.prank(mockCreditAccount);
            attacker.act(arbitrageSeeds[i]);
            
            (uint256 profit, uint256 loss, uint256 netResult) = attacker.getAttackStats();
            console.log("Arbitrage Profit: $", profit / 1e18);
            console.log("Arbitrage Loss: $", loss / 1e18);
            console.log("Net Arbitrage: $", netResult / 1e18);
            console.log("---");
        }
    }
    
    /// @notice Test emergency scenarios
    function testEmergencyScenarios() public {
        console.log("=== EMERGENCY SCENARIO TESTS ===");
        
        // Test protocol emergency response
        attacker.simulateProtocolEmergency();
        
        (uint256 profit, uint256 loss, uint256 netResult) = attacker.getAttackStats();
        console.log("Emergency Scenario Profit: $", profit / 1e18);
        console.log("Emergency Scenario Loss: $", loss / 1e18);
        console.log("Emergency Net Result: $", netResult / 1e18);
        
        // Emergency scenarios should typically result in losses for attackers
        // due to protocol protection mechanisms
    }
    
    /// @notice Comprehensive risk assessment
    function testRiskAssessment() public {
        console.log("=== COMPREHENSIVE RISK ASSESSMENT ===");
        
        // Test maximum risk scenarios
        uint256[] memory highRiskSeeds = new uint256[](10);
        for (uint256 i = 0; i < highRiskSeeds.length; i++) {
            highRiskSeeds[i] = 10000 + i * 1111; // Varied high-risk scenarios
        }
        
        uint256 maxProfitObserved = 0;
        uint256 maxLossObserved = 0;
        uint256 totalFundsAtRisk = 0;
        
        for (uint256 i = 0; i < highRiskSeeds.length; i++) {
            vm.prank(mockCreditAccount);
            attacker.act(highRiskSeeds[i]);
            
            (uint256 profit, uint256 loss, uint256 netResult) = attacker.getAttackStats();
            
            if (profit > maxProfitObserved) maxProfitObserved = profit;
            if (loss > maxLossObserved) maxLossObserved = loss;
            totalFundsAtRisk += profit + loss;
        }
        
        console.log("MAX PROFIT OBSERVED: $", maxProfitObserved / 1e18);
        console.log("MAX LOSS OBSERVED: $", maxLossObserved / 1e18);
        console.log("TOTAL FUNDS AT RISK: $", totalFundsAtRisk / 1e18);
        
        // Validate that funds at risk are within expected bounds
        assertLe(totalFundsAtRisk, 25000000e18, "Total funds at risk exceeds $25M limit");
        
        console.log("RISK ASSESSMENT: WITHIN ACCEPTABLE BOUNDS");
    }
}